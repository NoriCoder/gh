
-- Check if metatables are accessible (most exploits support this)

if getrawmetatable then
    local player = game.Players.LocalPlayer
    local mt = getrawmetatable(game) -- Get game's metatable
    local oldIndex = mt.__index -- Store original __index

    -- Make the metatable writable if needed
    setreadonly(mt, false)

    -- Hook the __index metamethod
    mt.__index = function(self, key)
        if self == player and key == "Kick" then
            -- Replace Kick with a no-op function
            return function(...) 
                print("Kick blocked! Args:", ...) -- Optional: Log the attempt
                return nil 
            end
        end
        return oldIndex(self, key) -- Fallback to original behavior
    end

    setreadonly(mt, true) -- Lock it back (optional, for safety)
else
    print("Exploit doesn't support metatables!")
end

local plrservice = game:GetService("Players")
if not decompile then
    game:Shutdown("Your executor lacks a decompile function.")
    return
end

-- Function to safely get services with retry logic
local function getServiceSafe(serviceName)
    local attempts = 0
    local maxAttempts = 50 -- ~5 seconds at 0.1s intervals
    local service
    repeat
        service = pcall(function() return game:GetService(serviceName) end) and game:GetService(serviceName) or nil
        attempts = attempts + 1
        if not service then task.wait(0.1) end
    until service or attempts >= maxAttempts
    return service
end

-- Function to safely get a property with retry logic
local function getPropertySafe(instance, propertyName)
    local attempts = 0
    local maxAttempts = 50 -- ~5 seconds at 0.1s intervals
    local property
    repeat
        property = pcall(function() return instance[propertyName] end) and instance[propertyName] or nil
        attempts = attempts + 1
        if not property then task.wait(0.1) end
    until property or attempts >= maxAttempts
    return property
end

-- Define services dynamically with fallback
local function initializeServices()
    local services = {}
    local replicatedStorage = getServiceSafe("ReplicatedStorage")
    if replicatedStorage then
        table.insert(services, {Service = replicatedStorage, Name = "ReplicatedStorage"})
    end

    local replicatedFirst = getServiceSafe("ReplicatedFirst")
    if replicatedFirst then
        table.insert(services, {Service = replicatedFirst, Name = "ReplicatedFirst"})
    end

    local starterPlayer = getServiceSafe("StarterPlayer")
    if starterPlayer then
        -- Safely check for StarterPlayerScripts
        local starterPlayerScripts = getPropertySafe(starterPlayer, "StarterPlayerScripts")
        if starterPlayerScripts then
            table.insert(services, {Service = starterPlayerScripts, Name = "StarterPlayerScripts"})
        end

        -- Safely check for StarterCharacterScripts
        local starterCharacterScripts = getPropertySafe(starterPlayer, "StarterCharacterScripts")
        if starterCharacterScripts then
            table.insert(services, {Service = starterCharacterScripts, Name = "StarterCharacterScripts"})
        end
    end

    local starterGui = getServiceSafe("StarterGui")
    if starterGui then
        table.insert(services, {Service = starterGui, Name = "StarterGui"})
    end

    if getnilinstances then -- Check if function exists
        table.insert(services, {Service = nil, Name = "NilInstances", GetDescendants = getnilinstances})
    end

    return services
end

-- Initialize services lazily
local services = {}
local deletedScripts = {LocalScripts = {}, ModuleScripts = {}}
local outputtedScripts = {}
local logQueue = {"Script initialized..."}

-- Track deletions with retry logic
local function setupDeletionTracking()
    services = initializeServices()
    for _, service in ipairs(services) do
        local container = service.Service or game
        local descendants
        local success = pcall(function()
            descendants = service.GetDescendants and service.GetDescendants() or container:GetDescendants()
        end)
        if success and descendants then
            for _, script in ipairs(descendants) do
                if script:IsA("LocalScript") or script:IsA("ModuleScript") then
                    script.AncestryChanged:Connect(function(_, parent)
                        if not parent then
                            local scriptType = script:IsA("LocalScript") and "LocalScripts" or "ModuleScripts"
                            if not deletedScripts[scriptType][script.Name] then
                                deletedScripts[scriptType][script.Name] = {Script = script:Clone(), Source = service.Name}
                                logQueue[#logQueue + 1] = "Deleted: " .. script.Name .. " (" .. service.Name .. ")"
                            end
                        end
                    end)
                end
            end
        end
    end
end
spawn(setupDeletionTracking) -- Run in a separate thread to avoid blocking

-- Wait for player and setup GUI
local me = plrservice.LocalPlayer or plrservice.PlayerAdded:Wait()
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ScreenGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = me:WaitForChild("PlayerGui")

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 800, 0, 700)
MainFrame.Position = UDim2.new(0.5, -200, 0.5, -175)
MainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local TitleBar = Instance.new("Frame")
TitleBar.Size = UDim2.new(1, 0, 0, 30)
TitleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame

local TitleText = Instance.new("TextLabel")
TitleText.Size = UDim2.new(0.8, 0, 1, 0)
TitleText.Position = UDim2.new(0, 10, 0, 0)
TitleText.BackgroundTransparency = 1
TitleText.Text = "Script Dumper"
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 18
TitleText.Font = Enum.Font.SourceSansBold
TitleText.TextXAlignment = Enum.TextXAlignment.Left
TitleText.Parent = TitleBar

local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -30, 0, 0)
CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 18
CloseButton.Font = Enum.Font.SourceSansBold
CloseButton.Parent = TitleBar

local ContentFrame = Instance.new("Frame")
ContentFrame.Size = UDim2.new(1, -20, 1, -50)
ContentFrame.Position = UDim2.new(0, 10, 0, 40)
ContentFrame.BackgroundTransparency = 1
ContentFrame.Parent = MainFrame

local LogFrame = Instance.new("ScrollingFrame")
LogFrame.Size = UDim2.new(1, 0, 0.65, 0)
LogFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
LogFrame.BorderSizePixel = 0
LogFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
LogFrame.ScrollBarThickness = 8
LogFrame.Parent = ContentFrame

local logEntries = {}
local logHeight = 0

local function addLogEntry(text)
    local color = Color3.fromRGB(200, 200, 200)
    if text:find("Deleted") then
        color = Color3.fromRGB(255, 50, 50)
    elseif text:find("Paused") then
        color = Color3.fromRGB(255, 150, 50)
    elseif text:find("Resumed") then
        color = Color3.fromRGB(50, 200, 50)
    elseif text:find("Failed") then
        color = Color3.fromRGB(255, 50, 50)
    end

    local entry = Instance.new("TextLabel")
    entry.Size = UDim2.new(1, -10, 0, 20)
    entry.Position = UDim2.new(0, 5, 0, logHeight)
    entry.BackgroundTransparency = 1
    entry.Text = text
    entry.TextColor3 = color
    entry.TextSize = 14
    entry.Font = Enum.Font.SourceSans
    entry.TextXAlignment = Enum.TextXAlignment.Left
    entry.TextYAlignment = Enum.TextYAlignment.Top
    entry.TextWrapped = true
    entry.Parent = LogFrame

    logHeight = logHeight + 20
    LogFrame.CanvasSize = UDim2.new(0, 0, 0, logHeight)
    LogFrame.CanvasPosition = Vector2.new(0, logHeight)
    table.insert(logEntries, entry)
end

for _, msg in ipairs(logQueue) do
    addLogEntry(msg)
end

local ButtonFrame = Instance.new("Frame")
ButtonFrame.Size = UDim2.new(1, 0, 0.3, 0)
ButtonFrame.Position = UDim2.new(0, 0, 0.7, 0)
ButtonFrame.BackgroundTransparency = 1
ButtonFrame.Parent = ContentFrame

local DumpAllButton = Instance.new("TextButton")
DumpAllButton.Size = UDim2.new(0.3, 0, 0.45, -5)
DumpAllButton.Position = UDim2.new(0, 0, 0, 5)
DumpAllButton.BackgroundColor3 = Color3.fromRGB(50, 100, 200)
DumpAllButton.Text = "Dump All"
DumpAllButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DumpAllButton.TextSize = 16
DumpAllButton.Font = Enum.Font.SourceSansBold
DumpAllButton.Parent = ButtonFrame

local DumpDeletedButton = Instance.new("TextButton")
DumpDeletedButton.Size = UDim2.new(0.3, 0, 0.45, -5)
DumpDeletedButton.Position = UDim2.new(0.35, 0, 0, 5)
DumpDeletedButton.BackgroundColor3 = Color3.fromRGB(150, 50, 200)
DumpDeletedButton.Text = "Dump Deleted"
DumpDeletedButton.TextColor3 = Color3.fromRGB(255, 255, 255)
DumpDeletedButton.TextSize = 16
DumpDeletedButton.Font = Enum.Font.SourceSansBold
DumpDeletedButton.Parent = ButtonFrame

local ClearButton = Instance.new("TextButton")
ClearButton.Size = UDim2.new(0.3, 0, 0.45, -5)
ClearButton.Position = UDim2.new(0.7, 0, 0, 5)
ClearButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
ClearButton.Text = "Clear Log"
ClearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ClearButton.TextSize = 16
ClearButton.Font = Enum.Font.SourceSansBold
ClearButton.Parent = ButtonFrame

-- Dragging functionality
local dragging, dragInput, dragStart, startPos
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)
TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Dumper Logic
local isDumping = false
local isPaused = false
local currentDumpType = nil

local function log(message)
    addLogEntry(message)
end

local function collectScripts(dumpType)
    local localScripts, moduleScripts = {}, {}
    if dumpType == "all" then
        for _, service in ipairs(services) do
            local descendants
            local success = pcall(function()
                descendants = service.GetDescendants and service.GetDescendants() or service.Service:GetDescendants()
            end)
            if success and descendants then
                for _, v in ipairs(descendants) do
                    if v:IsA("LocalScript") then
                        localScripts[v.Name] = {Script = v:Clone(), Source = service.Name}
                    elseif v:IsA("ModuleScript") then
                        moduleScripts[v.Name] = {Script = v:Clone(), Source = service.Name}
                    end
                end
            end
        end
    elseif dumpType == "deleted" then
        for name, data in pairs(deletedScripts.LocalScripts) do
            localScripts[name] = {Script = data.Script:Clone(), Source = data.Source}
        end
        for name, data in pairs(deletedScripts.ModuleScripts) do
            moduleScripts[name] = {Script = data.Script:Clone(), Source = data.Source}
        end
    end
    return localScripts, moduleScripts
end

local function decompileScript(script)
    local success, output = pcall(function()
        if script == nil then return {Success = false, "no script provided for decompileScript function"} end
        bytecode = "No byte code"
        if getscriptbytecode(script) then
            bytecode = getscriptbytecode(script)
            return bytecode and decompile(script) or "Failed to retrieve bytecode"
        else
            return bytecode and decompile(script) or "Failed to retrieve bytecode"
        end
    end)
    return {Success = success, Output = output or "Decompilation error"}
end

local marketplaceService = game:GetService("MarketplaceService")
local productInfo = marketplaceService:GetProductInfo(game.PlaceId)
local gameName = productInfo.Name:gsub("[^%w_%-%s]", ""):gsub("%s", "-")
local baseFolder = gameName
local localFolder = baseFolder .. "\\LocalScripts"
local moduleFolder = baseFolder .. "\\ModuleScripts"
local deletedFolder = baseFolder .. "\\DeletedScripts"

local function setupFolders()
    if not isfolder(baseFolder) then
        makefolder(baseFolder)
        makefolder(localFolder)
        makefolder(moduleFolder)
        makefolder(deletedFolder)
    end
end

local function dumpScripts(scriptTable, folder, scriptType)
    local dedupeCounter, scriptsFailed = 0, 0
    for name, data in pairs(scriptTable) do
        if not isDumping then return dedupeCounter, scriptsFailed end
        while isPaused do task.wait(0.1) end
        log("Decompiling: " .. name .. " (" .. data.Source .. ")")
        local result = decompileScript(data.Script)
        if result.Success then
            if not outputtedScripts[result.Output] then
                outputtedScripts[result.Output] = true
                local subFolder = folder .. "\\" .. data.Source
                if not isfolder(subFolder) then makefolder(subFolder) end
                local fileName = string.format("%s_%s_%d.lua", name, data.Source, os.time())
                writefile(subFolder .. "\\" .. fileName, result.Output)
                log("Dumped: " .. name .. " (" .. data.Source .. ")")
            else
                dedupeCounter = dedupeCounter + 1
                log("Deduped: " .. name .. " (" .. data.Source .. ")")
            end
        else
            scriptsFailed = scriptsFailed + 1
            log("Failed: " .. name .. " (" .. data.Source .. ") - " .. result.Output)
        end
        task.wait(0.01)
    end
    return dedupeCounter, scriptsFailed
end

local function tableLength(tbl)
    local count = 0
    for _ in pairs(tbl) do count = count + 1 end
    return count
end

local function startDump(dumpType, button)
    if not isDumping then
        isDumping = true
        isPaused = false
        currentDumpType = dumpType
        button.Text = "Pause"
        button.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
        setupFolders()
        log("Starting " .. (dumpType == "all" and "all scripts" or "deleted scripts") .. " dump...")
        local localScripts, moduleScripts = collectScripts(dumpType)
        local lsCount, msCount = tableLength(localScripts), tableLength(moduleScripts)
        log("LocalScripts: " .. lsCount)
        log("ModuleScripts: " .. msCount)

        local startTime = os.time()
        spawn(function()
            local dedupe1, failed1 = dumpScripts(localScripts, dumpType == "all" and localFolder or deletedFolder, "LocalScripts")
            if not isDumping then return end
            log("Dumped LocalScripts")
            local dedupe2, failed2 = dumpScripts(moduleScripts, dumpType == "all" and moduleFolder or deletedFolder, "ModuleScripts")
            if not isDumping then return end
            log("Dumped ModuleScripts")

            local elapsed = os.time() - startTime
            log("Finished in: " .. elapsed .. " seconds")
            log("Failed: " .. (failed1 + failed2))
            log("Deduped: " .. (dedupe1 + dedupe2))
            isDumping = false
            button.Text = dumpType == "all" and "Dump All" or "Dump Deleted"
            button.BackgroundColor3 = dumpType == "all" and Color3.fromRGB(50, 100, 200) or Color3.fromRGB(150, 50, 200)
        end)
    elseif currentDumpType == dumpType then
        if isPaused then
            isPaused = false
            button.Text = "Pause"
            button.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
            log("Resumed...")
        else
            isPaused = true
            button.Text = "Resume"
            button.BackgroundColor3 = Color3.fromRGB(100, 150, 50)
            log("Paused...")
        end
    end
end

-- Button Events
DumpAllButton.MouseButton1Click:Connect(function() startDump("all", DumpAllButton) end)
DumpDeletedButton.MouseButton1Click:Connect(function() startDump("deleted", DumpDeletedButton) end)

ClearButton.MouseButton1Click:Connect(function()
    for _, entry in ipairs(logEntries) do
        entry:Destroy()
    end
    logEntries = {}
    logHeight = 0
    LogFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    addLogEntry("Log cleared...")
end)

CloseButton.MouseButton1Click:Connect(function()
    isDumping = false
    ScreenGui:Destroy()
end)

-- Debug log
print("Script Dumper loaded in auto-execute")
